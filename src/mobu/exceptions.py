"""Exceptions for mobu."""

from __future__ import annotations

from abc import ABCMeta, abstractmethod
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from .constants import DATE_FORMAT

if TYPE_CHECKING:
    from typing import Any, Dict, List, Optional

    from aiohttp import ClientResponse

__all__ = [
    "CodeExecutionError",
    "FlockNotFoundException",
    "JupyterError",
    "JupyterTimeoutError",
    "MonkeyNotFoundException",
    "SlackError",
]


class FlockNotFoundException(Exception):
    """The named flock was not found."""

    def __init__(self, flock: str) -> None:
        self.flock = flock
        super().__init__(f"Flock {flock} not found")


class MonkeyNotFoundException(Exception):
    """The named monkey was not found."""

    def __init__(self, monkey: str) -> None:
        self.monkey = monkey
        super().__init__(f"Monkey {monkey} not found")


class SlackError(Exception, metaclass=ABCMeta):
    """Represents an exception that can be reported to Slack.

    Intended to be subclassed.  Subclasses must override the to_slack
    method.
    """

    def __init__(self, user: str, msg: str) -> None:
        self.user = user
        self.failed = datetime.now(tz=timezone.utc)
        self.started: Optional[datetime] = None
        self.event: Optional[str] = None
        super().__init__(msg)

    @abstractmethod
    def to_slack(self) -> Dict[str, Any]:
        """Build a Slack message suitable for sending to an incoming webook."""

    def common_fields(self) -> List[Dict[str, str]]:
        """Return common fields to put in any alert."""
        failed = self.failed.strftime(DATE_FORMAT)
        fields = [
            {"type": "mrkdwn", "text": f"*Failed at*\n{failed}"},
            {"type": "mrkdwn", "text": f"*User*\n{self.user}"},
        ]
        if self.started:
            started = self.started.strftime(DATE_FORMAT)
            fields.insert(
                0, {"type": "mrkdwn", "text": f"*Started at*\n{started}"}
            )
        if self.event:
            fields.append({"type": "mrkdwn", "text": f"*Event*\n{self.event}"})
        return fields


class CodeExecutionError(SlackError):
    """Error generated by code execution in a notebook on JupyterLab."""

    def __init__(
        self,
        user: str,
        code: str,
        *,
        error: Optional[str] = None,
        notebook: Optional[str] = None,
        status: Optional[str] = None,
    ) -> None:
        self.code = code
        self.error = error
        self.notebook = notebook
        self.status = status
        super().__init__(user, "Code execution failed")

    def __str__(self) -> str:
        if self.notebook:
            message = f"{self.user}: cell of notebook {self.notebook} failed"
            if self.status:
                message += f" (status: {self.status}"
            message += f"\nCode: {self.code}"
        else:
            message = f"{self.user}: running code '{self.code}' block failed"
        message += f"\nError: {self.error}"
        return message

    def to_slack(self) -> Dict[str, Any]:
        """Format the error as a Slack Block Kit message."""
        if self.notebook:
            intro = f"Error while running `{self.notebook}`"
        else:
            intro = "Error while running code"
        if self.status:
            intro += f"\n*Status*: {self.status}"

        fields = self.common_fields()

        code = self.code
        if not code.endswith("\n"):
            code += "\n"
        attachments = [
            {
                "color": "good",
                "blocks": [
                    {"type": "header", "text": "Code executed"},
                    {"type": "divider"},
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"```\n{code}```",
                        },
                    },
                ],
            }
        ]
        if self.error:
            error = self.error
            if error and not error.endswith("\n"):
                error += "\n"
            attachments.append(
                {
                    "color": "danger",
                    "blocks": [
                        {"type": "header", "text": "Error"},
                        {"type": "divider"},
                        {
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"```\n{error}```",
                            },
                        },
                    ],
                }
            )

        return {
            "blocks": [
                {"type": "section", "text": {"type": "mrkdwn", "text": intro}},
                {"type": "section", "fields": fields},
            ],
            "attachments": attachments,
        }


class JupyterError(SlackError):
    """Web error from JupyterHub or JupyterLab."""

    @classmethod
    async def from_response(
        cls, user: str, response: ClientResponse
    ) -> JupyterError:
        return cls(
            url=str(response.url),
            user=user,
            status=response.status,
            reason=response.reason,
            method=response.method,
            body=await response.text(),
        )

    def __init__(
        self,
        *,
        url: str,
        user: str,
        status: int,
        reason: Optional[str],
        method: str,
        body: str,
    ) -> None:
        self.url = url
        self.status = status
        self.reason = reason
        self.method = method
        self.body = body
        super().__init__(user, f"Status {status} from {method} {url}")

    def __str__(self) -> str:
        return (
            f"{self.user}: status {self.status} ({self.reason}) from"
            f" {self.method} {self.url}\nBody:\n{self.body}\n"
        )

    def to_slack(self) -> Dict[str, Any]:
        """Format the error as a Slack Block Kit message."""
        intro = f"Status {self.status} from {self.method} {self.url}"
        fields = self.common_fields()
        if self.reason:
            fields.append(
                {"type": "mrkdwn", "text": f"*Message*\n{self.reason}"}
            )
        return {
            "blocks": [
                {"type": "section", "text": {"type": "mrkdwn", "text": intro}},
                {"type": "section", "fields": fields},
            ]
        }


class JupyterTimeoutError(SlackError):
    """Timed out waiting for the lab to spawn."""

    def to_slack(self) -> Dict[str, Any]:
        """Format the error as a Slack Block Kit message."""
        return {
            "blocks": [
                {
                    "type": "section",
                    "text": {"type": "mrkdwn", "text": str(self)},
                },
                {"type": "section", "fields": self.common_fields()},
            ]
        }
