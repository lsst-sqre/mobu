"""Exceptions for mobu."""

from __future__ import annotations

from datetime import datetime
from typing import Optional, Self

from aiohttp import ClientResponse, ClientResponseError
from safir.datetime import format_datetime_for_logging
from safir.slack.blockkit import (
    SlackBaseBlock,
    SlackBaseField,
    SlackCodeBlock,
    SlackException,
    SlackMessage,
    SlackTextBlock,
    SlackTextField,
)

__all__ = [
    "CachemachineError",
    "CodeExecutionError",
    "FlockNotFoundException",
    "JupyterError",
    "JupyterResponseError",
    "JupyterTimeoutError",
    "MobuSlackException",
    "MonkeyNotFoundException",
    "TAPClientError",
]


class FlockNotFoundException(Exception):
    """The named flock was not found."""

    def __init__(self, flock: str) -> None:
        self.flock = flock
        super().__init__(f"Flock {flock} not found")


class MonkeyNotFoundException(Exception):
    """The named monkey was not found."""

    def __init__(self, monkey: str) -> None:
        self.monkey = monkey
        super().__init__(f"Monkey {monkey} not found")


class NotebookRepositoryError(Exception):
    """The repository containing notebooks to run is not valid."""


class MobuSlackException(SlackException):
    """Represents an exception that can be reported to Slack.

    This is equivalent to `~safir.slack.blockkit.SlackException` except it
    adds some additional fields that mobu uses. It is intended to be
    subclassed. Subclasses must override the `to_slack` method.
    """

    def __init__(self, user: str, msg: str) -> None:
        super().__init__(msg, user)
        self.started_at: Optional[datetime] = None
        self.event: Optional[str] = None
        self.annotations: dict[str, str] = {}

    def to_slack(self) -> SlackMessage:
        """Format the error as a Slack Block Kit message.

        This is the generic version that only reports the text of the
        exception and common fields. Most classes will want to override it.
        Do not use any of the formatting of the general Safir
        `~safir.slack.blockkit.SlackException` class, since it includes an
        exception type field that we don't care about and adds some additional
        text to the main message that we don't want.
        """
        return SlackMessage(
            message=str(self),
            blocks=self.common_blocks(),
            fields=self.common_fields(),
        )

    def common_blocks(self) -> list[SlackBaseBlock]:
        """Return common blocks to put in any alert.

        Returns
        -------
        list of SlackBaseBlock
            Common blocks to add to the Slack message.
        """
        blocks: list[SlackBaseBlock] = []
        if self.annotations.get("node"):
            node = self.annotations["node"]
            blocks.append(SlackTextBlock(heading="Node", text=node))
        if self.annotations.get("notebook"):
            notebook = self.annotations["notebook"]
            if self.annotations.get("cell"):
                cell = self.annotations["cell"]
                text = f"`{notebook}` cell {cell}"
                blocks.append(SlackTextBlock(heading="Cell", text=text))
            else:
                block = SlackTextBlock(heading="Notebook", text=notebook)
                blocks.append(block)
        elif self.annotations.get("cell"):
            cell = self.annotations["cell"]
            blocks.append(SlackTextBlock(heading="Cell", text=cell))
        return blocks

    def common_fields(self) -> list[SlackBaseField]:
        """Return common fields to put in any alert.

        Returns
        -------
        list of SlackBaseField
            Common fields to add to the Slack message.
        """
        failed_at = format_datetime_for_logging(self.failed_at)
        fields: list[SlackBaseField] = [
            SlackTextField(heading="Failed at", text=failed_at),
        ]
        if self.user:
            fields.append(SlackTextField(heading="User", text=self.user))
        if self.started_at:
            started_at = format_datetime_for_logging(self.started_at)
            field = SlackTextField(heading="Started at", text=started_at)
            fields.insert(0, field)
        if self.event:
            fields.append(SlackTextField(heading="Event", text=self.event))
        if self.annotations.get("image"):
            image = self.annotations["image"]
            fields.append(SlackTextField(heading="Image", text=image))
        return fields


class CachemachineError(MobuSlackException):
    """Failed to obtain a valid image list from cachemachine."""

    def __init__(self, user: str, msg: str) -> None:
        super().__init__(user, f"Cachemachine error: {msg}")


class CodeExecutionError(MobuSlackException):
    """Error generated by code execution in a notebook on JupyterLab."""

    def __init__(
        self,
        user: str,
        code: str,
        *,
        code_type: str = "code",
        error: Optional[str] = None,
        status: Optional[str] = None,
    ) -> None:
        super().__init__(user, "Code execution failed")
        self.code = code
        self.code_type = code_type
        self.error = error
        self.status = status

    def __str__(self) -> str:
        if self.annotations.get("notebook"):
            notebook = self.annotations["notebook"]
            if self.annotations.get("cell"):
                cell = self.annotations["cell"]
                msg = f"{self.user}: cell {cell} of notebook {notebook} failed"
            else:
                msg = f"{self.user}: cell of notebook {notebook} failed"
            if self.status:
                msg += f" (status: {self.status})"
            msg += f"\nCode: {self.code}"
        else:
            msg = f"{self.user}: running {self.code_type} '{self.code}' failed"
        msg += f"\nError: {self.error}"
        return msg

    def to_slack(self) -> SlackMessage:
        """Format the error as a Slack Block Kit message."""
        if self.annotations.get("notebook"):
            notebook = self.annotations["notebook"]
            intro = f"Error while running `{notebook}`"
        else:
            intro = f"Error while running {self.code_type}"
        if self.status:
            intro += f" (status: {self.status})"

        attachments: list[SlackBaseBlock] = [
            SlackCodeBlock(heading="Code executed", code=self.code)
        ]
        if self.error:
            attachment = SlackCodeBlock(heading="Error", code=self.error)
            attachments.insert(0, attachment)
        return SlackMessage(
            message=intro,
            fields=self.common_fields(),
            blocks=self.common_blocks(),
            attachments=attachments,
        )


class JupyterError(MobuSlackException):
    """An exception occurred when talking to JupyterHub or JupyterLab."""

    def __init__(self, user: str, exc: Exception) -> None:
        super().__init__(user, f"{type(exc).__name__}: {str(exc)}")


class JupyterResponseError(MobuSlackException):
    """Web response error from JupyterHub or JupyterLab."""

    @classmethod
    def from_exception(cls, user: str, exc: ClientResponseError) -> Self:
        return cls(
            url=str(exc.request_info.url),
            user=user,
            status=exc.status,
            reason=exc.message or type(exc).__name__,
            method=exc.request_info.method,
        )

    @classmethod
    async def from_response(cls, user: str, response: ClientResponse) -> Self:
        return cls(
            url=str(response.url),
            user=user,
            status=response.status,
            reason=response.reason or "",
            method=response.method,
            body=await response.text(),
        )

    def __init__(
        self,
        *,
        url: str,
        user: str,
        status: int,
        reason: str,
        method: str,
        body: Optional[str] = None,
    ) -> None:
        super().__init__(user, f"Status {status} from {method} {url}")
        self.url = url
        self.status = status
        self.reason = reason
        self.method = method
        self.body = body

    def __str__(self) -> str:
        result = (
            f"{self.user}: status {self.status} ({self.reason}) from"
            f" {self.method} {self.url}"
        )
        if self.body:
            result += f"\nBody:\n{self.body}\n"
        return result

    def to_slack(self) -> SlackMessage:
        """Format the error as a Slack Block Kit message."""
        intro = f"Status {self.status} from {self.method} {self.url}"
        fields = self.common_fields()
        if self.reason:
            fields.append(SlackTextField(heading="Message", text=self.reason))
        return SlackMessage(
            message=intro, fields=fields, blocks=self.common_blocks()
        )


class JupyterSpawnError(MobuSlackException):
    """The Jupyter Lab pod failed to spawn."""

    @classmethod
    def from_exception(cls, user: str, log: str, exc: Exception) -> Self:
        return cls(user, log, f"{type(exc).__name__}: {str(exc)}")

    def __init__(
        self, user: str, log: str, message: Optional[str] = None
    ) -> None:
        if message:
            message = f"Spawning lab failed: {message}"
        else:
            message = "Spawning lab failed"
        super().__init__(user, message)
        self.log = log

    def to_slack(self) -> SlackMessage:
        """Format the error as a Slack Block Kit message."""
        message = super().to_slack()
        message.blocks.append(SlackTextBlock(heading="Log", text=self.log))
        return message


class JupyterTimeoutError(MobuSlackException):
    """Timed out waiting for the lab to spawn."""

    def __init__(self, user: str, msg: str, log: Optional[str] = None) -> None:
        super().__init__(user, msg)
        self.log = log

    def to_slack(self) -> SlackMessage:
        """Format the error as a Slack Block Kit message."""
        message = super().to_slack()
        if self.log:
            message.blocks.append(SlackTextBlock(heading="Log", text=self.log))
        return message


class JupyterWebSocketError(MobuSlackException):
    """Unexpected messages on the session WebSocket."""


class TAPClientError(MobuSlackException):
    """Creating a TAP client failed."""

    def __init__(self, user: str, exc: Exception) -> None:
        msg = f"Unable to create TAP client: {type(exc).__name__}: {str(exc)}"
        super().__init__(user, msg)
